// Generated by CoffeeScript 1.3.3
(function() {
  var Chart, Telemachus, addTelemetry, charts, customCharts, customLayouts, dateString, defaultLayout, durationString, hourMinSec, layouts, missionTimeString, orderOfMagnitude, reloadLayout, removeTelemetry, resetChart, setChart, setLayout, siUnit, standardCharts, standardLayouts, stripInsignificantZeros, testCharts, testLayouts,
    __slice = [].slice;

  standardCharts = {
    "Altitude": {
      series: ["v.altitude", "v.heightFromTerrain"],
      yaxis: {
        label: "Altitude",
        unit: "m",
        min: 0,
        max: null
      }
    },
    "Apoapsis and Periapsis": {
      series: ["o.ApA", "o.PeA"],
      yaxis: {
        label: "Altitude",
        unit: "m",
        min: 0,
        max: null
      }
    },
    "Atmospheric Density": {
      series: ["v.atmosphericDensity"],
      yaxis: {
        label: "Altitude",
        unit: "Pa",
        min: 0,
        max: null
      }
    },
    "Dynamic Pressure": {
      series: ["v.dynamicPressure"],
      yaxis: {
        label: "Dynamic Pressure",
        unit: "Pa",
        min: 0,
        max: null
      }
    },
	"Vessel G-Force": {
      series: ["v.geeForce"],
      yaxis: {
        label: "Acceleration",
        unit: "Gs",
        min: null,
        max: null
      }
    },
    "Sensor G-Force": {
      series: ["s.sensor.acc"],
      yaxis: {
        label: "Acceleration",
        unit: "Gs",
        min: null,
        max: null
      }
    },
    "Gravity": {
      series: ["s.sensor.grav"],
      yaxis: {
        label: "Gravity",
        unit: "m/s\u00B2",
        min: 0,
        max: null
      }
    },
    "Pressure": {
      series: ["s.sensor.pres"],
      yaxis: {
        label: "Pressure",
        unit: "Pa",
        min: 0,
        max: null
      }
    },
    "Temperature": {
      series: ["s.sensor.temp"],
      yaxis: {
        label: "Temperature",
        unit: "\u00B0C",
        min: null,
        max: null
      }
    },
    "Orbital Velocity": {
      series: ["v.orbitalVelocity"],
      yaxis: {
        label: "Velocity",
        unit: "m/s",
        min: 0,
        max: null
      }
    },
    "Surface Velocity": {
      series: ["v.surfaceSpeed", "v.verticalSpeed"],
      yaxis: {
        label: "Velocity",
        unit: "m/s",
        min: null,
        max: null
      }
    },
    "Angular Velocity": {
      series: ["v.angularVelocity"],
      yaxis: {
        label: "Angular Velocity",
        unit: "\u00B0/s",
        min: 0,
        max: null
      }
    },
    "Liquid Fuel and Oxidizer": {
      series: ["r.resource[LiquidFuel]", "r.resource[Oxidizer]"],
      yaxis: {
        label: "Volume",
        unit: "L",
        min: 0,
        max: null
      }
    },
    "Electric Charge": {
      series: ["r.resource[ElectricCharge]"],
      yaxis: {
        label: "Electric Charge",
        unit: "Wh",
        min: 0,
        max: null
      }
    },
    "Monopropellant": {
      series: ["r.resource[MonoPropellant]"],
      yaxis: {
        label: "Volume",
        unit: "L",
        min: 0,
        max: null
      }
    },
    "Heading": {
      series: ["n.heading"],
      yaxis: {
        label: "Angle",
        unit: "\u00B0",
        min: 0,
        max: 360
      }
    },
    "Pitch": {
      series: ["n.pitch"],
      yaxis: {
        label: "Angle",
        unit: "\u00B0",
        min: -90,
        max: 90
      }
    },
    "Roll": {
      series: ["n.roll"],
      yaxis: {
        label: "Angle",
        unit: "\u00B0",
        min: -180,
        max: 180
      }
    },
    "Target Distance": {
      series: ["tar.distance"],
      yaxis: {
        label: "Distance",
        unit: "m",
        min: 0,
        max: null
      }
    },
    "Relative Velocity": {
      series: ["tar.o.relativeVelocity"],
      yaxis: {
        label: "Velocity",
        unit: "m/s",
        min: 0,
        max: null
      }
    },
    "True Anomaly": {
      series: ["o.trueAnomaly"],
      yaxis: {
        label: "Angle",
        unit: "\u00B0",
        min: null,
        max: null
      }
    },
    "Map": {
      series: ["v.long", "v.lat", "v.name", "v.body"],
      type: "map"
    }
  };

  testCharts = {
    "Sine and Cosine": {
      series: ["test.sin", "test.cos"],
      yaxis: {
        label: "Angle",
        unit: "\u00B0",
        min: null,
        max: null
      }
    },
    "Quadratic": {
      series: ["test.square"],
      yaxis: {
        label: "Altitude",
        unit: "m",
        min: 0,
        max: null
      }
    },
    "Random": {
      series: ["test.rand"],
      yaxis: {
        label: "Velocity",
        unit: "m/s",
        min: null,
        max: null
      }
    },
    "Square Root": {
      series: ["test.sqrt"],
      yaxis: {
        label: "Velocity",
        unit: "m/s",
        min: 0,
        max: null
      }
    }
  };

  customCharts = {};

  charts = {};

  standardLayouts = {
    "Flight Dynamics": {
      charts: ["Altitude", "Orbital Velocity", "True Anomaly"],
      telemetry: ["o.sma", "o.eccentricity", "o.inclination", "o.lan", "o.argumentOfPeriapsis", "o.timeOfPeriapsisPassage", "o.trueAnomaly", "v.altitude", "v.orbitalVelocity"]
    },
    "Retrofire": {
      charts: ["Map", "Altitude", "Surface Velocity"],
      telemetry: ["v.altitude", "v.heightFromTerrain", "v.surfaceSpeed", "v.verticalSpeed", "v.lat", "v.long"]
    },
    "Booster Systems": {
      charts: ["Liquid Fuel and Oxidizer", "Dynamic Pressure", "Atmospheric Density"],
      telemetry: ["r.resource[LiquidFuel]", "r.resourceMax[LiquidFuel]", "r.resource[Oxidizer]", "r.resourceMax[Oxidizer]", "v.dynamicPressure", "v.atmosphericDensity"]
    },
    "Instrumentation": {
      charts: ["G-Force", "Pressure", "Temperature"],
      telemetry: ["s.sensor.acc", "s.sensor.pres", "s.sensor.temp", "s.sensor.grav"]
    },
    "Electrical, Environmental and Comm.": {
      charts: ["Electric Charge", "Pressure", "Temperature"],
      telemetry: ["r.resource[ElectricCharge]", "r.resourceMax[ElectricCharge]", "s.sensor.pres", "s.sensor.temp"]
    },
    "Guidance, Navigation and Control": {
      charts: ["Heading", "Pitch", "Roll"],
      telemetry: ["r.resource[MonoPropellant]", "r.resourceMax[MonoPropellant]", "n.heading", "n.pitch", "n.roll"]
    },
    "Rendezvous and Docking": {
      charts: ["Target Distance", "Relative Velocity"],
      telemetry: ["tar.name", "tar.o.sma", "tar.o.eccentricity", "tar.o.inclination", "tar.o.lan", "tar.o.argumentOfPeriapsis", "tar.o.timeOfPeriapsisPassage", "tar.o.trueAnomaly", "tar.distance", "tar.o.relativeVelocity"]
    }
  };

  testLayouts = {
    "Test": {
      charts: ["Sine and Cosine", "Quadratic", "Random"],
      telemetry: ['test.rand', 'test.sin', 'test.cos', 'test.square', 'test.exp', 'test.sqrt', 'test.log']
    }
  };

  customLayouts = {};

  layouts = {};

  defaultLayout = "Flight Dynamics";

  Telemachus = {
    CELESTIAL_BODIES: ["Kerbol", "Kerbin", "Mun", "Minmus", "Moho", "Eve", "Duna", "Ike", "Jool", "Laythe", "Vall", "Bop", "Tylo", "Gilly", "Pol", "Dres", "Eeloo"],
    RESOURCES: ["ElectricCharge", "SolidFuel", "LiquidFuel", "Oxidizer", "MonoPropellant", "IntakeAir", "XenonGas"],
    api: {},
    telemetry: {
      "p.paused": 0,
      "v.missionTime": 0,
      "t.universalTime": 0
    },
    lastUpdate: null,
    apiSubscriptionCounts: {
      "t.universalTime": 1,
      "v.missionTime": 1
    },
    $telemetrySubscribers: $(),
    $alertSubscribers: $(),
    format: function(value, api) {
      var units;
      if (!(value != null)) {
        return "No Data";
      } else if ($.isArray(value)) {
        return this.format(value[1][0], api);
      } else {
        units = this.api[api].units.toLowerCase();
        if (units in this.formatters) {
          return this.formatters[units](value);
        } else {
          return value.toString();
        }
      }
    },
    subscribe: function() {
      var $collection, api, apis, _i, _len, _ref;
      $collection = arguments[0], apis = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      this.$telemetrySubscribers = this.$telemetrySubscribers.add($collection);
      $collection.data("telemachus-api-subscriptions", apis);
      for (_i = 0, _len = apis.length; _i < _len; _i++) {
        api = apis[_i];
        this.apiSubscriptionCounts[api] = ((_ref = this.apiSubscriptionCounts[api]) != null ? _ref : 0) + $collection.length;
      }
      return $collection;
    },
    unsubscribe: function() {
      var $collection, api, apis, elem, _i, _j, _len, _len1;
      $collection = arguments[0], apis = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      this.$telemetrySubscribers = this.$telemetrySubscribers.not($collection);
      for (_i = 0, _len = $collection.length; _i < _len; _i++) {
        elem = $collection[_i];
        apis = $(elem).data("telemachus-api-subscriptions");
        if (apis != null) {
          for (_j = 0, _len1 = apis.length; _j < _len1; _j++) {
            api = apis[_j];
            if (!(api in this.apiSubscriptionCounts)) {
              continue;
            }
            this.apiSubscriptionCounts[api] = this.apiSubscriptionCounts[api] - 1;
            if (this.apiSubscriptionCounts[api] <= 0) {
              delete this.apiSubscriptionCounts[api];
            }
          }
        }
      }
      return $collection;
    },
    subscribeAlerts: function($collection) {
      return this.$alertSubscribers = this.$alertSubscribers.add($collection);
    },
    unsubscribeAlerts: function($collection) {
      return this.$alertSubscribers = this.$alertSubscribers.not($collection);
    },
    loadAPI: function(testMode) {
      var _this = this;
      if (testMode) {
        this.api = {
          "p.paused": {
            apistring: 'p.paused',
            name: "Paused",
            units: 'UNITLESS'
          },
          "v.missionTime": {
            apistring: 'v.missionTime',
            name: "Mission Time",
            units: 'TIME'
          },
          "t.universalTime": {
            apistring: 't.universalTime',
            name: "Universal Time",
            units: 'DATE'
          },
          "test.rand": {
            apistring: 'test.rand',
            name: "Random",
            units: 'UNITLESS'
          },
          "test.sin": {
            apistring: 'test.sin',
            name: "Sine",
            units: 'UNITLESS'
          },
          "test.cos": {
            apistring: 'test.cos',
            name: "Cosine",
            units: 'UNITLESS'
          },
          "test.square": {
            apistring: 'test.square',
            name: "Quadratic",
            units: 'UNITLESS'
          },
          "test.exp": {
            apistring: 'test.exp',
            name: "Exponential",
            units: 'UNITLESS'
          },
          "test.sqrt": {
            apistring: 'test.sqrt',
            name: "Square Root",
            units: 'UNITLESS'
          },
          "test.log": {
            apistring: 'test.log',
            name: "Logarithmic",
            units: 'UNITLESS'
          }
        };
        this.testStart = Date.now();
        this.testDownlink();
        return $.Deferred().resolve(this.api).promise();
      } else {
        return $.get("datalink", {
          api: "a.api"
        }, "json").then(function(data, textStatus, jqXHR) {
          var api, i, r, resourceApi, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2;
          _ref = JSON.parse(data).api;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            api = _ref[_i];
            if (api.apistring.match(/^b\./)) {
              for (i = _j = 0, _ref1 = _this.CELESTIAL_BODIES.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
                _this.api[api.apistring + ("[" + i + "]")] = api;
              }
            } else if (api.apistring.match(/^r\./)) {
              if (api.apistring !== "r.resourceCurrent") {
                _ref2 = _this.RESOURCES;
                for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
                  r = _ref2[_k];
                  resourceApi = $.extend({}, api);
                  resourceApi.name = r.replace(/([a-z])([A-Z])/g, "$1 $2");
                  if (api.apistring.match(/Max$/)) {
                    resourceApi.name += " Max";
                  }
                  _this.api[api.apistring + ("[" + r + "]")] = resourceApi;
                }
              }
            } else if (api.plotable && api.apistring !== "s.sensor") {
              _this.api[api.apistring] = api;
            }
          }
          _this.downlink();
          return _this.api;
        }, function() {
          var timeout;
          _this.$alertSubscribers.trigger("telemetryAlert", ["No Signal Found"]);
          timeout = $.Deferred();
          setTimeout((function() {
            return timeout.resolve();
          }), 5000);
          return timeout.then(function() {
            return _this.loadAPI();
          });
        });
      }
    },
    downlink: function() {
      var api, i, key, query, url,
        _this = this;
      query = {};
      i = 0;
      query["p"] = "p.paused";
      for (api in this.apiSubscriptionCounts) {
        if (api !== "p.paused") {
          query["a" + (i++)] = api;
        }
      }
      url = "datalink?" + (((function() {
        var _results;
        _results = [];
        for (key in query) {
          api = query[key];
          _results.push("" + key + "=" + api);
        }
        return _results;
      })()).join("&"));
      return $.get(url).done(function(data, textStatus, jqXHR) {
        var value;
        try {
          data = JSON.parse(data);
        } catch (error) {
          _this.$alertSubscribers.trigger("telemetryAlert", ["Bad Data"]);
          setTimeout((function() {
            return _this.downlink();
          }), 5000);
          return;
        }
        _this.telemetry["p.paused"] = data.p;
        switch (data.p) {
          case 4:
            _this.$alertSubscribers.trigger("telemetryAlert", ["Signal Lost"]);
            break;
          case 3:
            _this.$alertSubscribers.trigger("telemetryAlert", ["Signal Terminated"]);
            break;
          case 2:
            _this.$alertSubscribers.trigger("telemetryAlert", ["Signal Power Loss"]);
            break;
          case 1:
            _this.$alertSubscribers.trigger("telemetryAlert", ["Game Paused"]);
            break;
          case 0:
            _this.$alertSubscribers.trigger("telemetryAlert", [null]);
        }
        if (data.p !== 1) {
          _this.lastUpdate = Date.now();
          _this.telemetry = {};
          for (key in data) {
            value = data[key];
            if (data.p === 0 || ["p.paused", "v.missionTime", "t.universalTime"].indexOf(query[key]) !== -1) {
              _this.telemetry[query[key]] = value;
            } else {
              _this.telemetry[query[key]] = null;
            }
          }
          _this.$telemetrySubscribers.trigger("telemetry", [_this.telemetry]);
        }
        return setTimeout((function() {
          return _this.downlink();
        }), 500);
      }).fail(function() {
        _this.$alertSubscribers.trigger("telemetryAlert", ["No Signal Found"]);
        return setTimeout((function() {
          return _this.downlink();
        }), 5000);
      });
    },
    testDownlink: function() {
      var api, lastRand, paused, rand, t, x, _ref,
        _this = this;
      rand = Math.random() * 1000;
      paused = rand >= 10 ? 0 : Math.floor(rand / 2);
      switch (paused) {
        case 4:
          this.$alertSubscribers.trigger("telemetryAlert", ["Signal Lost"]);
          break;
        case 3:
          this.$alertSubscribers.trigger("telemetryAlert", ["Signal Terminated"]);
          break;
        case 2:
          this.$alertSubscribers.trigger("telemetryAlert", ["Signal Power Loss"]);
          break;
        case 1:
          this.$alertSubscribers.trigger("telemetryAlert", ["Game Paused"]);
          break;
        case 0:
          this.$alertSubscribers.trigger("telemetryAlert", [null]);
      }
      if (paused !== 1) {
        this.lastUpdate = Date.now();
        t = (this.lastUpdate - this.testStart) / 1000;
        lastRand = (_ref = this.telemetry["test.rand"]) != null ? _ref : rand;
        this.telemetry = {
          "p.paused": paused,
          "v.missionTime": t,
          "t.universalTime": this.lastUpdate / 1000
        };
        x = t / 120;
        for (api in this.apiSubscriptionCounts) {
          if (!(api in this.telemetry)) {
            this.telemetry[api] = (function() {
              if (paused !== 0) {
                return null;
              } else {
                switch (api) {
                  case 'test.rand':
                    return lastRand + (rand - 500) / 10;
                  case 'test.sin':
                    return 1000 * Math.sin(x * 2 * Math.PI);
                  case 'test.cos':
                    return 1000 * Math.cos(x * 2 * Math.PI);
                  case 'test.square':
                    return x * x;
                  case 'test.exp':
                    return Math.exp(x);
                  case 'test.sqrt':
                    return Math.sqrt(x);
                  case 'test.log':
                    return Math.log(x);
                }
              }
            })();
          }
        }
        this.$telemetrySubscribers.trigger("telemetry", [this.telemetry]);
      }
      return setTimeout((function() {
        return _this.testDownlink();
      }), paused === 0 ? 500 : 5000);
    },
    formatters: {
      unitless: function(v) {
        if (typeof v === "number") {
          return v.toPrecision(6);
        } else {
          return v;
        }
      },
      velocity: function(v) {
        return siUnit(v, "m/s");
      },
      deg: function(v) {
        return v.toPrecision(6) + "\u00B0";
      },
      distance: function(v) {
        return siUnit(v, "m");
      },
      time: function(v) {
        return durationString(v);
      },
      string: function(v) {
        return v;
      },
      temp: function(v) {
        return v.toPrecision(6) + "\u00B0C";
      },
      pres: function(v) {
        return siUnit(v / 1000, "Pa");
      },
      grav: function(v) {
        return siUnit(v, "m/s\u00B2");
      },
      acc: function(v) {
        return v.toPrecision(6) + " G";
      },
      date: function(v) {
        return dateString(v);
      }
    }
  };

  Chart = (function() {

    function Chart(canvas, series, yaxis) {
      var _this = this;
      this.$canvas = $(canvas);
      this.data = [];
      this.series = series.slice();
      this.xaxis = {
        min: 0,
        max: 1,
        ticks: []
      };
      this.yaxis = $.extend({
        tickSpacingMin: 30
      }, yaxis);
      this.padding = {
        left: 70,
        top: 10,
        right: 10,
        bottom: 30
      };
      if (this.series.length <= 1) {
        this.padding.bottom = 10;
      }
      this.seriesStyles = ['rgb(192, 128, 0)', 'rgb(0, 128, 0)', 'rgb(0, 128, 192)', 'rgb(192, 192, 192)'];
      this.gridStyle = 'rgb(96, 96, 96)';
      this.axisStyle = 'rgb(192, 192, 192)';
      this.font = 'bold 10pt "Helvetic Neue",Helvetica,Arial,sans serif';
      this.fontSize = 10;
      this.tickLength = 5;
      this.tickLabelSpacing = 10;
      this.legendSpacing = 40;
      this.legendBoxSize = 5;
      this.$canvas.resize(function(event) {
        return _this.draw();
      });
      this.draw();
    }

    Chart.prototype.addSample = function(x, series) {
      var e, i, windowEnd, windowStart, _i, _len, _ref;
      this.data.push([x].concat(series));
      this.data.sort(function(a, b) {
        return a[0] - b[0];
      });
      windowStart = 0;
      windowEnd = this.data.length - 1;
      _ref = this.data;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        e = _ref[i];
        if (e[0] < this.xaxis.min) {
          windowStart = i;
        }
        if (e[0] <= this.xaxis.max) {
          windowEnd = i;
        }
      }
      return this.data = this.data.slice(windowStart, windowEnd + 1);
    };

    Chart.prototype.draw = function() {
      var chartHeight, chartWidth, ctx, height, i, sample, width, ymax, ymin, _i, _j, _k, _len, _ref, _ref1, _ref2, _ref3, _ref4;
      width = this.$canvas.width();
      height = this.$canvas.height();
      if (width === 0 || height === 0) {
        return;
      }
      chartWidth = width - (this.padding.left + this.padding.right);
      chartHeight = height - (this.padding.top + this.padding.bottom);
      ctx = this.$canvas[0].getContext('2d');
      ctx.save();
      ctx.clearRect(0, 0, width, height);
      this.xaxis.scale = chartWidth / (this.xaxis.max - this.xaxis.min);
      if ((this.yaxis.min != null) && (this.yaxis.max != null)) {
        ymin = this.yaxis.min;
        ymax = this.yaxis.max;
      } else {
        ymin = (_ref = this.yaxis.min) != null ? _ref : Infinity;
        ymax = (_ref1 = this.yaxis.max) != null ? _ref1 : -Infinity;
        _ref2 = this.data;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          sample = _ref2[_i];
          for (i = _j = 1, _ref3 = sample.length; 1 <= _ref3 ? _j < _ref3 : _j > _ref3; i = 1 <= _ref3 ? ++_j : --_j) {
            if (!(sample[i] != null)) {
              continue;
            }
            if (this.yaxis.min == null) {
              ymin = Math.min(sample[i], ymin);
            }
            if (this.yaxis.max == null) {
              ymax = Math.max(sample[i], ymax);
            }
          }
        }
        if (ymin === Infinity) {
          ymin = 0;
        }
        if (ymax === -Infinity) {
          ymax = 0;
        }
      }
      this.yaxis.ticks = this.calculateTicks(this.yaxis, ymin, ymax, (chartHeight / this.yaxis.tickSpacingMin) | 0);
      ymin = this.yaxis.ticks[0];
      ymax = this.yaxis.ticks[this.yaxis.ticks.length - 1];
      this.yaxis.scale = chartHeight / (ymax - ymin);
      ctx.translate(this.padding.left, height - this.padding.bottom);
      ctx.scale(1, -1);
      this.drawGrid(ctx, chartWidth, chartHeight, this.xaxis.min, ymin);
      for (i = _k = _ref4 = this.series.length; _ref4 <= 1 ? _k <= 1 : _k >= 1; i = _ref4 <= 1 ? ++_k : --_k) {
        this.drawSeries(ctx, this.xaxis.min, ymin, i);
      }
      ctx.clearRect(-this.padding.left, -this.padding.bottom, this.padding.left, height);
      ctx.clearRect(-this.padding.left, -this.padding.bottom, width, this.padding.bottom);
      this.drawAxes(ctx, chartWidth, chartHeight, ymin);
      if (this.series.length > 1) {
        this.drawLegend(ctx, chartWidth);
      }
      return ctx.restore();
    };

    Chart.prototype.calculateTicks = function(axis, min, max, maxIntervals) {
      var bottom, bottomFixed, i, interval, intervalAbove, intervalBelow, intervalValue, intervals, magnitude, nextBottom, nextInterval, nextTop, reduce, tick, ticks, top, topFixed, _ref, _ref1, _ref2;
      bottomFixed = axis.min != null;
      topFixed = axis.max != null;
      reduce = function(interval) {
        switch (interval[0]) {
          case 5:
            return [2, interval[1]];
          case 2:
            return [1, interval[1]];
          case 1:
            return [5, interval[1] - 1];
        }
      };
      intervalValue = function(interval) {
        return interval[0] * Math.pow(10, interval[1]);
      };
      intervalAbove = function(num, interval) {
        var m, v;
        v = intervalValue(interval);
        m = num < 0 ? v + num % v : num % v;
        return num - m + v;
      };
      intervalBelow = function(num, interval) {
        var m, v;
        v = intervalValue(interval);
        m = num < 0 ? v + num % v : num % v;
        if (m === 0) {
          return num - v;
        } else {
          return num - m;
        }
      };
      if (max < min) {
        if (topFixed && bottomFixed) {
          _ref = [max, min], min = _ref[0], max = _ref[1];
        } else if (topFixed) {
          min = max;
        } else {
          max = min;
        }
      }
      if (maxIntervals < 1) {
        maxIntervals = 1;
      }
      bottom = min;
      top = max;
      if (bottomFixed && topFixed && top - bottom >= 90 && ((top - bottom) % 90 === 0)) {
        intervals = [15, 30, 45, 90];
        while (((top - bottom) / intervals[0]) > maxIntervals) {
          intervals.shift();
        }
        return (function() {
          var _i, _ref1, _results;
          _results = [];
          for (tick = _i = bottom, _ref1 = intervals[0]; bottom <= top ? _i <= top : _i >= top; tick = _i += _ref1) {
            _results.push(tick);
          }
          return _results;
        })();
      }
      if (min === max) {
        if (max === 0) {
          return [0, 1];
        } else {
          magnitude = orderOfMagnitude(max);
          interval = [1, magnitude];
          if (!bottomFixed) {
            bottom = intervalBelow(min, interval);
          }
          if (!(topFixed && !bottomFixed)) {
            top = intervalAbove(max, interval);
          }
          topFixed = bottomFixed = true;
        }
      } else {
        magnitude = Math.max(orderOfMagnitude(min), orderOfMagnitude(max));
        interval = [1, magnitude];
        if (!bottomFixed) {
          bottom = intervalBelow(min, interval);
        }
        if (!topFixed) {
          top = intervalAbove(min, interval);
        }
      }
      while (true) {
        nextInterval = reduce(interval);
        nextBottom = bottomFixed ? bottom : intervalBelow(min, nextInterval);
        nextTop = topFixed ? top : intervalAbove(max, nextInterval);
        if ((nextTop - nextBottom) / intervalValue(nextInterval) > maxIntervals) {
          break;
        }
        _ref1 = [nextBottom, nextTop, nextInterval], bottom = _ref1[0], top = _ref1[1], interval = _ref1[2];
      }
      ticks = [bottom, top];
      [].splice.apply(ticks, [1, 0].concat(_ref2 = (function() {
        var _i, _ref3, _ref4, _results;
        _results = [];
        for (i = _i = _ref3 = intervalAbove(bottom, interval), _ref4 = intervalValue(interval); _ref3 <= top ? _i < top : _i > top; i = _i += _ref4) {
          _results.push(i);
        }
        return _results;
      })())), _ref2;
      return ticks;
    };

    Chart.prototype.drawGrid = function(ctx, width, height, xoffset, yoffset) {
      var tick, x, y, _i, _j, _len, _len1, _ref, _ref1;
      ctx.save();
      ctx.strokeStyle = this.gridStyle;
      ctx.beginPath();
      _ref = this.xaxis.ticks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tick = _ref[_i];
        x = Math.round(this.xaxis.scale * (tick - xoffset) - 0.5) + 0.5;
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
      }
      _ref1 = this.yaxis.ticks;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        tick = _ref1[_j];
        y = Math.round(this.yaxis.scale * (tick - yoffset) - 0.5) + 0.5;
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
      }
      ctx.stroke();
      ctx.strokeStyle = this.axisStyle;
      ctx.beginPath();
      y = Math.round(-this.yaxis.scale * yoffset - 0.5) + 0.5;
      ctx.moveTo(0, y);
      ctx.lineTo(width, y);
      ctx.stroke();
      return ctx.restore();
    };

    Chart.prototype.drawSeries = function(ctx, xmin, ymin, i) {
      var d, j, _i, _len, _ref, _ref1;
      ctx.save();
      ctx.lineWidth = 2;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.strokeStyle = this.seriesStyles[i - 1];
      ctx.beginPath();
      _ref = this.data;
      for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {
        d = _ref[j];
        if (d[i] != null) {
          if (((_ref1 = this.data[j - 1]) != null ? _ref1[i] : void 0) != null) {
            ctx.lineTo(this.xaxis.scale * (d[0] - xmin), this.yaxis.scale * (d[i] - ymin));
          } else {
            ctx.moveTo(this.xaxis.scale * (d[0] - xmin), this.yaxis.scale * (d[i] - ymin));
          }
        }
      }
      ctx.stroke();
      return ctx.restore();
    };

    Chart.prototype.drawAxes = function(ctx, width, height, yoffset) {
      var PREFIXES, prefix, tick, tickMagnitude, tickScale, y, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      PREFIXES = ['f', 'p', 'n', '\u03bc', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];
      ctx.save();
      ctx.strokeStyle = this.axisStyle;
      ctx.beginPath();
      ctx.moveTo(-this.tickLength, 0.5);
      ctx.lineTo(width + 0.5, 0.5);
      ctx.moveTo(0.5, 0);
      ctx.lineTo(0.5, height + 0.5);
      _ref = this.yaxis.ticks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tick = _ref[_i];
        if (!(tick !== yoffset)) {
          continue;
        }
        y = Math.round(this.yaxis.scale * (tick - yoffset) - 0.5) + 0.5;
        ctx.moveTo(-this.tickLength, y);
        ctx.lineTo(0.5, y);
      }
      ctx.stroke();
      tickMagnitude = Math.max(orderOfMagnitude(this.yaxis.ticks[0]), orderOfMagnitude(this.yaxis.ticks[this.yaxis.ticks.length - 1]));
      if (tickMagnitude > 0) {
        tickMagnitude -= 1;
      }
      tickScale = Math.ceil(tickMagnitude / 3);
      if (tickScale > 0) {
        tickScale -= 1;
      }
      prefix = PREFIXES[tickScale + 5];
      ctx.font = this.font;
      ctx.fillStyle = this.axisStyle;
      ctx.textBaseline = 'middle';
      ctx.scale(1, -1);
      ctx.save();
      ctx.textAlign = 'center';
      ctx.translate(-(this.padding.left - this.fontSize), -height / 2);
      ctx.rotate(-Math.PI / 2);
      if (((this.yaxis.unit != null) && this.yaxis.unit !== '') || prefix !== '') {
        ctx.fillText("" + this.yaxis.label + " (" + prefix + ((_ref1 = this.yaxis.unit) != null ? _ref1 : '') + ")", 0, 0, height);
      } else {
        ctx.fillText("" + this.yaxis.label, 0, 0, height);
      }
      ctx.restore();
      ctx.textAlign = 'right';
      tickScale = Math.pow(1000, -tickScale);
      _ref2 = this.yaxis.ticks;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        tick = _ref2[_j];
        y = Math.round(this.yaxis.scale * (tick - yoffset) - 0.5) + 0.5;
        ctx.fillText(stripInsignificantZeros((tick * tickScale).toFixed(3)), -this.tickLabelSpacing, -y);
      }
      return ctx.restore();
    };

    Chart.prototype.drawLegend = function(ctx, width, series) {
      var i, legendWidth, name, seriesWidths, x, _i, _len, _ref;
      ctx.save();
      ctx.font = this.font;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      seriesWidths = (function() {
        var _i, _len, _ref, _results;
        _ref = this.series;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          name = _ref[_i];
          _results.push(ctx.measureText(name).width);
        }
        return _results;
      }).call(this);
      legendWidth = seriesWidths.reduce(function(sum, width) {
        return sum + width;
      }) + (this.series.length - 1) * this.legendSpacing;
      ctx.scale(1, -1);
      x = width / 2 - legendWidth / 2;
      _ref = this.series;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        name = _ref[i];
        ctx.fillStyle = this.seriesStyles[i];
        ctx.fillRect(x, this.padding.bottom - (this.fontSize + this.legendBoxSize / 2), this.legendBoxSize, this.legendBoxSize);
        ctx.fillStyle = this.axisStyle;
        ctx.fillText(name, x + this.fontSize, this.padding.bottom - this.fontSize);
        x += seriesWidths[i] + this.legendSpacing;
      }
      return ctx.restore();
    };

    return Chart;

  })();

  $(document).ready(function() {
    var $chartMenus, $layoutMenu, chart, populateLayoutMenu, savedDefault, testMode, _ref, _ref1;
    if (window.localStorage != null) {
      customCharts = (_ref = JSON.parse(window.localStorage.getItem("telemachus.console.charts"))) != null ? _ref : {};
      $.extend(charts, standardCharts, customCharts);
      customLayouts = (_ref1 = JSON.parse(window.localStorage.getItem("telemachus.console.layouts"))) != null ? _ref1 : {};
      $.extend(layouts, standardLayouts, customLayouts);
      savedDefault = window.localStorage.getItem("defaultLayout");
      if ((savedDefault != null) && savedDefault in layouts) {
        defaultLayout = savedDefault;
      }
    }
    testMode = window.location.protocol === "file:" || window.location.hash === "#test";
    if (testMode) {
      $.extend(layouts, testLayouts);
      $.extend(charts, testCharts);
      defaultLayout = "Test";
    }
    $layoutMenu = $("body > header nav ul");
    populateLayoutMenu = function() {
      var layout, _results;
      $layoutMenu.empty();
      _results = [];
      for (layout in layouts) {
        _results.push($layoutMenu.append($("<li>").append($("<a>").attr({
          href: "#"
        }).text(layout))));
      }
      return _results;
    };
    populateLayoutMenu();
    $layoutMenu.on("click", "li a", function(event) {
      var layoutName;
      event.preventDefault();
      layoutName = $(this).text().trim();
      setLayout(layoutName);
      $("#deleteLayout").prop("disabled", !(layoutName in customLayouts));
      return $(this).closest("ul").hide();
    });
    $chartMenus = $(".chart nav ul");
    for (chart in charts) {
      $chartMenus.append($("<li>").append($("<a>").attr({
        href: "#"
      }).text(chart)));
    }
    $chartMenus.on("click", "li a", function(event) {
      event.preventDefault();
      setChart($(this).closest(".chart"), $(this).text());
      return $(this).closest("ul").hide();
    });
    $(document).on("click.dropdown", ".dropdown > a", function() {
      var $menu, $this;
      $this = $(this);
      $menu = $this.next();
      return $menu.toggle().css({
        left: Math.max($this.position().left + $this.width() - $menu.outerWidth(), 0),
        top: $this.position().top + Math.min($(window).height() - $menu.outerHeight() - $this.offset().top, $this.height())
      });
    });
    $(document).on("click.dropdown", function() {
      return $(".dropdown").not($(event.target).parents()).children("ul").hide();
    });
    setLayout(defaultLayout);
    $("#deleteLayout").prop("disabled", !(defaultLayout in customLayouts));
    $("#apiCategory").change(function(event) {
      var api, apistring, category, _ref2, _results;
      category = $("#apiCategory").val();
      $("#apiSelect").empty();
      _ref2 = Telemachus.api;
      _results = [];
      for (apistring in _ref2) {
        api = _ref2[apistring];
        if (apistring.match(category)) {
          _results.push($("#apiSelect").append($("<option>").attr("value", apistring).text(api.name)));
        }
      }
      return _results;
    });
    $("#telemetry").on("click", "dt a", function(event) {
      event.preventDefault();
      return removeTelemetry($(this).parent());
    });
    $(".alert").on("telemetryAlert", function(event, message) {
      var $display, $this;
      $(".alert").text(message != null ? message : "");
      if (message != null) {
        $this = $(this);
        $display = $this.siblings(".display");
        return $this.css("marginTop", -($display.outerHeight() + $this.height()) / 2);
      }
    });
    if (window.localStorage != null) {
      $("#saveLayout").click(function(event) {
        var elem, name;
        event.preventDefault();
        name = window.prompt("What name would you like to save this layout under?", $("h1").text().trim()).trim();
        if (!(name != null) || name === "" || (name in layouts && !window.confirm("That name is already in use. Are you sure you want to overwrite the existing layout?"))) {
          return;
        }
        layouts[name] = customLayouts[name] = {
          charts: (function() {
            var _i, _len, _ref2, _results;
            _ref2 = $(".chart h2");
            _results = [];
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              elem = _ref2[_i];
              _results.push($(elem).text().trim());
            }
            return _results;
          })(),
          telemetry: (function() {
            var _i, _len, _ref2, _results;
            _ref2 = $("#telemetry dt");
            _results = [];
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              elem = _ref2[_i];
              _results.push($(elem).data("api"));
            }
            return _results;
          })()
        };
        window.localStorage.setItem("telemachus.console.layouts", JSON.stringify(customLayouts));
        populateLayoutMenu();
        $("h1").text(name);
        return $("#deleteLayout").prop("disabled", false);
      });
      $("#deleteLayout").click(function(event) {
        var layoutName;
        event.preventDefault();
        if (window.confirm("Are you sure you want to delete the current custom layout?")) {
          layoutName = $("h1").text().trim();
          if (!(layoutName in customLayouts)) {
            return;
          }
          delete customLayouts[layoutName];
          window.localStorage.setItem("telemachus.console.layouts", JSON.stringify(customLayouts));
          if (layoutName in standardLayouts) {
            layouts[layoutName] = standardLayouts[layoutName];
            reloadLayout();
            return $("#deleteLayout").prop("disabled", true);
          } else {
            delete layouts[layoutName];
            populateLayoutMenu();
            return $("body > header nav ul li:first-child a").click();
          }
        }
      });
    } else {
      $("#saveLayout").prop("disabled", true);
      $("#deleteLayout").prop("disabled", true);
    }
    Telemachus.subscribeAlerts($(".alert"));
    Telemachus.loadAPI(testMode).done(function() {
      $("#apiCategory").change();
      return reloadLayout();
    });
    setInterval(function() {
      var missionTime, universalTime;
      if (Telemachus.telemetry["p.paused"] !== 1) {
        missionTime = Telemachus.telemetry["v.missionTime"];
        if (missionTime > 0) {
          missionTime += (Date.now() - Telemachus.lastUpdate) / 1000;
        }
        universalTime = Telemachus.telemetry["t.universalTime"] + (Date.now() - Telemachus.lastUpdate) / 1000;
        $("#met").text(missionTimeString(missionTime));
        return $("#ut").text(dateString(universalTime));
      }
    }, 1000);
    $("#telemetry form").submit(function(event) {
      event.preventDefault();
      return addTelemetry($("#apiSelect").val());
    });
    return $(window).resize(function() {
      var $alert, $chart, $display, $telemetry, $telemetryAdd, $telemetryForm, $telemetryList, $telemetrySelect, buttonWidth, canvas, display, margins, winHeight, _i, _j, _len, _len1, _ref2, _ref3, _ref4;
      winHeight = Math.min($(window).height(), (_ref2 = window.innerHeight) != null ? _ref2 : 1e6);
      $("#container").height(winHeight - ($("#container").position().top + $("body > footer").outerHeight(true)));
      _ref3 = $(".display", "#charts");
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        display = _ref3[_i];
        $display = $(display);
        $chart = $display.closest(".chart");
        $display.height($chart.height() - $display.position().top - 20);
        $alert = $display.siblings(".alert");
        $alert.css("fontSize", $display.height() / 5).css("marginTop", -($display.outerHeight() + $alert.height()) / 2);
      }
      _ref4 = $("canvas");
      for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
        canvas = _ref4[_j];
        $(canvas).prop({
          width: $(canvas).width(),
          height: $(canvas).height()
        });
      }
      $telemetry = $("#telemetry");
      $telemetryList = $("dl", $telemetry);
      $telemetryForm = $("form", $telemetry);
      margins = $telemetryList.outerHeight(true) - $telemetryList.height();
      $telemetryList.height($telemetryForm.position().top - $telemetryList.position().top - margins);
      $("form", $telemetry).width($telemetry.width());
      $telemetrySelect = $("#apiSelect");
      $telemetryAdd = $("form input", $telemetry);
      buttonWidth = $telemetryAdd.outerWidth(true) + 5;
      return $telemetrySelect.width($telemetry.width() - buttonWidth);
    }).resize();
  });

  addTelemetry = function(api) {
    var $dd;
    if ((api != null) && api in Telemachus.api && $("#telemetry dd[data-api='" + api + "']").length === 0) {
      $("<dt>").data("api", api).text(Telemachus.api[api].name + " ").append($("<a>").attr({
        href: "#",
        title: "Remove"
      })).appendTo("#telemetry dl");
      $dd = $("<dd>").data("api", api).text("No Data").appendTo("#telemetry dl").on("telemetry", function(event, data) {
        var value;
        value = data[api];
        return $dd.text(Telemachus.format(value, api));
      });
      return Telemachus.subscribe($dd, api);
    }
  };

  removeTelemetry = function(elem) {
    var $elem;
    $elem = $(elem).next().addBack();
    Telemachus.unsubscribe($elem);
    return $elem.remove();
  };

  resetChart = function(elem) {
    var $display;
    $display = $(".display", elem).empty();
    return Telemachus.unsubscribe($display);
  };

  setChart = function(elem, chartName) {
    var $canvas, $display, $map, apis, body, chart, e, map, marker;
    resetChart(elem);
    chart = charts[chartName];
    if (chart == null) {
      return;
    }
    $("h2", elem).text(chartName);
    $display = $(".display", elem);
    Telemachus.subscribe.apply(Telemachus, [$display].concat(__slice.call(chart.series)));
    if (chart.type === "map") {
      $map = $("<div>").appendTo($display);
      map = new L.KSP.Map($map[0], {
        layers: [L.KSP.CelestialBody.KERBIN],
        zoom: L.KSP.CelestialBody.KERBIN.defaultLayer.options.maxZoom,
        center: [0, 0],
        bodyControl: false,
        layerControl: true,
        scaleControl: true
      });
      map.fitWorld();
      body = L.KSP.CelestialBody.KERBIN;
      marker = null;
      return $display.on("telemetry", function(event, data) {
        var bodyName, long, _ref;
        bodyName = (_ref = data["v.body"]) != null ? _ref.toUpperCase() : void 0;
        if (data["p.paused"] !== 0) {
          if (marker != null) {
            map.removeLayer(marker);
            return marker = null;
          }
        } else if (bodyName != null) {
          if (!(bodyName in L.KSP.CelestialBody)) {
            if ((bodyName != null) && (body != null)) {
              map.removeLayer(body);
              return body = null;
            }
          } else {
            if (body !== L.KSP.CelestialBody[data["v.body"].toUpperCase()]) {
              map.removeLayer(body);
              body = L.KSP.CelestialBody[data["v.body"].toUpperCase()];
              map.addLayer(body);
            }
            long = data["v.long"] > 180 ? data["v.long"] - 360 : data["v.long"];
            if (!(marker != null)) {
              marker = L.marker([data["v.lat"], data["v.long"]]);
              return map.addLayer(marker);
            } else {
              marker.setLatLng([data["v.lat"], long]);
              marker.bindPopup(data["v.name"] + " </br>Latitude: " + data["v.lat"] + "</br>Longitude: " + data["v.long"]);
              return marker.update();
            }
          }
        }
      });
    } else {
      $canvas = $("<canvas>").attr({
        width: $display.width(),
        height: $display.height()
      }).appendTo($display);
      apis = chart.series;
      chart = new Chart($canvas, (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = apis.length; _i < _len; _i++) {
          e = apis[_i];
          if (e in Telemachus.api) {
            _results.push(Telemachus.api[e].name);
          }
        }
        return _results;
      })(), chart.yaxis);
      return $display.on("telemetry", function(event, data) {
        var i, missionTime, sample, t, x, _i, _len;
        t = data["t.universalTime"];
        missionTime = data["v.missionTime"];
        chart.xaxis.min = t - 300;
        chart.xaxis.max = t;
        chart.xaxis.ticks = ((function() {
          var _i, _ref, _ref1, _results;
          _results = [];
          for (x = _i = _ref = t - missionTime % 60, _ref1 = t - 300; _i > _ref1; x = _i += -60) {
            if (missionTime > 0 && (t - x - 0.01) <= missionTime) {
              _results.push(x);
            }
          }
          return _results;
        })()).reverse();
        sample = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = apis.length; _i < _len; _i++) {
            e = apis[_i];
            _results.push(data[e]);
          }
          return _results;
        })();
        for (i = _i = 0, _len = sample.length; _i < _len; i = ++_i) {
          e = sample[i];
          if ($.isArray(e)) {
            sample[i] = e[1][0];
          }
        }
        chart.addSample(t, sample);
        return chart.draw();
      });
    }
  };

  reloadLayout = function() {
    return setLayout($("h1").text().trim());
  };

  setLayout = function(name) {
    var elem, i, layout, telemetry, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
    if (name in layouts) {
      window.localStorage.setItem("defaultLayout", name);
      $("h1").text(name);
      layout = layouts[name];
      _ref = $("#telemetry dl dt");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        removeTelemetry(elem);
      }
      _ref1 = layout.telemetry;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        telemetry = _ref1[_j];
        addTelemetry(telemetry);
      }
      _ref2 = $(".chart");
      _results = [];
      for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
        elem = _ref2[i];
        _results.push(setChart(elem, layout.charts[i]));
      }
      return _results;
    }
  };

  orderOfMagnitude = function(v) {
    if (v === 0) {
      return 0;
    }
    return Math.floor(Math.log(Math.abs(v)) / Math.LN10 + 1.0000000000000001);
  };

  siUnit = function(v, unit) {
    var prefixes, scale;
    if (unit == null) {
      unit = "";
    }
    if (v === 0) {
      return "0 " + unit;
    }
    prefixes = ['\u03bc', 'm', '', 'k', 'M', 'G', 'T'];
    scale = Math.ceil(orderOfMagnitude(v) / 3);
    if (scale <= 0 && ++scale < 0) {
      scale = 0;
    } else if (scale === 1) {
      scale = 2;
    } else if (scale >= prefixes.length) {
      scale = prefixes.length - 1;
    }
    return (v / Math.pow(1000, scale - 2)).toPrecision(6) + " " + prefixes[scale] + unit;
  };

  stripInsignificantZeros = function(v) {
    return v.toString().replace(/((\.\d*?[1-9])|\.)0+($|e)/, '$2$3');
  };

  hourMinSec = function(t) {
    var hour, min, sec;
    hour = (t / 3600) | 0;
    if (hour < 10) {
      hour = "0" + hour;
    }
    t %= 3600;
    min = (t / 60) | 0;
    if (min < 10) {
      min = "0" + min;
    }
    sec = (t % 60).toFixed();
    if (sec < 10) {
      sec = "0" + sec;
    }
    return "" + hour + ":" + min + ":" + sec;
  };

  dateString = function(t) {
    var day, year;
    year = ((t / (365 * 24 * 3600)) | 0) + 1;
    t %= 365 * 24 * 3600;
    day = ((t / (24 * 3600)) | 0) + 1;
    t %= 24 * 3600;
    return "Year " + year + ", Day " + day + ", " + (hourMinSec(t)) + " UT";
  };

  missionTimeString = function(t) {
    var result;
    result = "T+";
    if (t >= 365 * 24 * 3600) {
      result += (t / (365 * 24 * 3600) | 0) + ":";
      t %= 365 * 24 * 3600;
      if (t < 24 * 3600) {
        result += "0:";
      }
    }
    if (t >= 24 * 3600) {
      result += (t / (24 * 3600) | 0) + ":";
    }
    t %= 24 * 3600;
    return result + hourMinSec(t) + " MET";
  };

  durationString = function(t) {
    var result;
    result = t < 0 ? "-" : "";
    t = Math.abs(t);
    if (t >= 365 * 24 * 3600) {
      result += (t / (365 * 24 * 3600) | 0) + " years ";
      t %= 365 * 24 * 3600;
      if (t < 24 * 3600) {
        result += "0 days ";
      }
    }
    if (t >= 24 * 3600) {
      result += (t / (24 * 3600) | 0) + " days ";
    }
    t %= 24 * 3600;
    return result + hourMinSec(t);
  };

}).call(this);
